<!doctype html>

<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>EPL Picks Manager</title>

<!-- React (no build step) -->
<script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

<!-- Babel (JSX in this file) -->
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

<!-- PapaParse for CSV -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>

<!-- Chart.js for graphs -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

<style>
  :root { --bg:#0b1220; --card:#101a33; --text:#e7eefc; --muted:#9fb0d0; --line:#233458; --accent:#1b3bff; }
  body { margin:0; font-family:-apple-system,system-ui,Segoe UI,Roboto,Arial; background:var(--bg); color:var(--text); }
  a { color: inherit; text-decoration: none; }
  .wrap { max-width: 1400px; margin: 0 auto; padding: 18px; }
  h1 { margin: 0 0 10px; font-size: 20px; }
  .row { display:flex; gap:12px; flex-wrap:wrap; align-items:flex-start; }
  .card { background:var(--card); border:1px solid var(--line); border-radius:14px; padding:12px; margin-bottom:12px; }
  .card h2 { margin:0 0 10px; font-size: 14px; color: var(--muted); font-weight: 600; letter-spacing: .2px; }
  .card h3 { margin:12px 0 8px; font-size: 13px; color: var(--muted); font-weight: 600; }
  input, select, button, textarea {
    background:#0d1730; color:var(--text); border:1px solid var(--line);
    border-radius:10px; padding:10px; font-size: 14px;
  }
  button { cursor:pointer; transition: all 0.2s; }
  button:hover { opacity: 0.8; }
  button.primary { background:var(--accent); border-color:var(--accent); }
  button.danger { background:#a31616; border-color:#a31616; }
  button.small { padding: 6px 12px; font-size: 12px; }
  .muted { color: var(--muted); font-size: 12px; }
  .grid { overflow:auto; max-width: 100%; border-radius: 12px; border:1px solid var(--line); }
  table { border-collapse: collapse; width: max-content; min-width: 100%; }
  th, td { border:1px solid var(--line); padding: 8px; white-space: nowrap; }
  th { position: sticky; top:0; background:#0d1730; z-index:2; }
  td.sticky, th.sticky { position: sticky; left:0; background:#0d1730; z-index:3; font-weight:700; }
  td.sticky { z-index:1; font-weight:600; }
  .badge { display:inline-block; padding:4px 8px; border-radius:999px; border:1px solid var(--line); color:var(--muted); font-size:12px; }
  .badge.large { padding:8px 12px; font-size:14px; }
  .badge.success { background:#1a4d2e; border-color:#2d7a4a; color:#7CFFB2; }
  .badge.warning { background:#4d3d1a; border-color:#7a6a2d; color:#FFD07C; }
  .badge.danger { background:#4d1a1a; border-color:#7a2d2d; color:#FF8C8C; }
  .pill { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .heat0 { background:#c6efce; color:#111; }
  .heat1 { background:#ffeb9c; color:#111; }
  .heat2 { background:#f4cccc; color:#111; }
  .small { font-size: 12px; }
  .stat-grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:12px; margin-bottom:12px; }
  .stat-card { background:#0d1730; border:1px solid var(--line); border-radius:10px; padding:12px; }
  .stat-value { font-size:24px; font-weight:800; margin:4px 0; }
  .stat-label { font-size:11px; color:var(--muted); text-transform:uppercase; letter-spacing:0.5px; }
  .tabs { display:flex; gap:8px; flex-wrap:wrap; margin: 10px 0 14px; overflow-x: auto; }
  .tab {
    padding:10px 12px; border-radius: 999px; border:1px solid var(--line);
    background:#0d1730; color:var(--muted); font-weight:600; font-size: 13px; white-space: nowrap;
  }
  .tab.active { background: var(--accent); border-color: var(--accent); color: white; }
  .ok { color:#7CFFB2; }
  .warn { color:#FFD07C; }
  .bad { color:#FF8C8C; }
  .right { text-align:right; }
  .center { text-align:center; }
  .loading { text-align: center; padding: 40px; }
  .spinner { border: 3px solid var(--line); border-top: 3px solid var(--accent); border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 0 auto; }
  @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
  .readonly-banner { background: #2a4a7c; padding: 8px 12px; border-radius: 10px; margin-bottom: 12px; text-align: center; font-size: 13px; }
  .rank-1 { background: #FFD700; color: #111; font-weight: 800; }
  .rank-2 { background: #C0C0C0; color: #111; font-weight: 800; }
  .rank-3 { background: #CD7F32; color: #111; font-weight: 800; }
  .rank-up { color: #7CFFB2; }
  .rank-down { color: #FF8C8C; }
  .rank-same { color: var(--muted); }
  .chart-container { position: relative; height: 400px; margin: 20px 0; }
  .view-toggle { display: flex; gap: 8px; margin-bottom: 12px; flex-wrap: wrap; }
  .selector { margin-bottom: 12px; }
  .selector select { width: 100%; max-width: 300px; }
  .comparison-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
  @media (max-width: 768px) { 
    .comparison-grid { grid-template-columns: 1fr; }
    .stat-grid { grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); }
  }
  .highlight-box { background: rgba(27, 59, 255, 0.1); border: 1px solid var(--accent); border-radius: 8px; padding: 12px; margin: 8px 0; }
  .export-btn { margin-top: 12px; }
</style>


  </head>

  <body>
    <div id="root"></div>


<script type="text/babel">
  const { useEffect, useRef, useState } = React;

  const SHEET_ID = "1x9gMQl64X4WcR4yoLznln3CWUoqbtddg4xM7rUWBCwY";

  function normaliseTeamName(name){
    return (name ?? "").toString().trim();
  }

  function toInt(val){
    const n = parseInt((val ?? "").toString(), 10);
    return Number.isFinite(n) ? n : 0;
  }

  // Assigns standard competition ranks (1,1,3‚Ä¶) to an already-sorted-descending array.
  // Each item must have a numeric `points` property.  Returns new array with `rank` added.
  function assignRanks(sorted){
    return sorted.map((item, idx) => {
      let rank;
      if(idx === 0) rank = 1;
      else rank = sorted[idx-1].points === item.points ? sorted[idx-1].rank : idx + 1;
      return { ...item, rank };
    });
  }

  function useHashRoute(){
    const getRoute = () => (window.location.hash || "#/dashboard").replace("#", "");
    const [route, setRoute] = useState(getRoute());
    useEffect(() => {
      const onHash = () => setRoute(getRoute());
      window.addEventListener("hashchange", onHash);
      return () => window.removeEventListener("hashchange", onHash);
    }, []);
    return [route, (r) => window.location.hash = "#" + r];
  }

  function Tab({label, route, current, setRoute}){
    const active = current === route;
    return (
      <a className={"tab" + (active ? " active" : "")} href={"#" + route} onClick={(e)=>{e.preventDefault(); setRoute(route);}}>
        {label}
      </a>
    );
  }

  async function fetchSheetAsCSV(sheetName, gid){
    const url = gid 
      ? `https://docs.google.com/spreadsheets/d/${SHEET_ID}/export?format=csv&gid=${gid}`
      : `https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?tqx=out:csv&sheet=${encodeURIComponent(sheetName)}`;
    
    const response = await fetch(url);
    if(!response.ok) {
      throw new Error(`Failed to fetch ${sheetName}: HTTP ${response.status}`);
    }
    
    const text = await response.text();
    
    return new Promise((resolve, reject) => {
      Papa.parse(text, {
        complete: (results) => resolve(results.data),
        error: (error) => reject(error)
      });
    });
  }

  async function fetchSheetData(){
    try {
      let picksData;
      
      try {
        picksData = await fetchSheetAsCSV("PICKS");
      } catch(e1) {
        try {
          picksData = await fetchSheetAsCSV("PICKS", 0);
        } catch(e2) {
          throw new Error("Could not fetch PICKS sheet.");
        }
      }

      if(!picksData || picksData.length < 2){
        throw new Error("PICKS sheet is empty or has no data");
      }

      const picksHeader = picksData[0];
      const compIdx = picksHeader.findIndex(h => 
        String(h).toLowerCase().includes('competitor')
      );
      
      if(compIdx === -1) {
        throw new Error(`No 'Competitor' column found in PICKS.`);
      }

      const maxGWs = 38;
      const gwCols = {};
      for(let gw=1; gw<=maxGWs; gw++){
        const idx = picksHeader.findIndex(h => String(h).trim() === `GW${gw}`);
        if(idx !== -1) gwCols[gw] = idx;
      }

      const competitors = [];
      const picks = {};
      
      for(let r=1; r<picksData.length; r++){
        const row = picksData[r];
        if(!row || row.length === 0) continue;
        
        const c = normaliseTeamName(row[compIdx]);
        if(!c) continue;
        
        competitors.push(c);
        picks[c] = {};
        
        for(let gw=1; gw<=maxGWs; gw++){
          const idx = gwCols[gw];
          if(idx === undefined) continue;
          const t = normaliseTeamName(row[idx]);
          if(t) picks[c][gw] = t;
        }
      }

      let points = {};
      try {
        const pointsData = await fetchSheetAsCSV("POINTS");
        if(pointsData && pointsData.length > 1){
          const ptsHeader = pointsData[0];
          const compIdx2 = ptsHeader.findIndex(h => 
            String(h).toLowerCase().includes('competitor')
          );
          
          const gwCols2 = {};
          for(let gw=1; gw<=maxGWs; gw++){
            const idx = ptsHeader.findIndex(h => String(h).trim() === `GW${gw}`);
            if(idx !== -1) gwCols2[gw] = idx;
          }
          
          for(let r=1; r<pointsData.length; r++){
            const row = pointsData[r];
            if(!row || row.length === 0) continue;
            
            const c = normaliseTeamName(row[compIdx2]);
            if(!c) continue;
            
            points[c] = {};
            for(let gw=1; gw<=maxGWs; gw++){
              const idx = gwCols2[gw];
              if(idx === undefined) continue;
              const v = toInt(row[idx]);
              if(v) points[c][gw] = v;
            }
          }
        }
      } catch(e){
        console.log("POINTS sheet not found (optional)");
      }

      let teams = [];
      try {
        const teamsData = await fetchSheetAsCSV("TEAMS");
        if(teamsData && teamsData.length > 0){
          for(let r=0; r<teamsData.length; r++){
            const row = teamsData[r];
            if(!row || row.length === 0) continue;
            const v = normaliseTeamName(row[0]);
            if(v) teams.push(v);
          }
        }
      } catch(e){
        console.log("TEAMS sheet not found");
      }

      if(!teams.length){
        const s = new Set();
        for(const c of competitors){
          Object.values(picks[c] || {}).forEach(t => {
            const normalized = normaliseTeamName(t);
            if(normalized) s.add(normalized);
          });
        }
        teams = Array.from(s).sort((a,b)=>a.localeCompare(b));
      }

      // Determine current gameweek
      let currentGW = 0;
      for(let gw=1; gw<=maxGWs; gw++){
        let hasData = false;
        for(const c of competitors){
          if(toInt(points?.[c]?.[gw]) > 0){
            hasData = true;
            break;
          }
        }
        if(hasData) currentGW = gw;
      }

      return { competitors, teams, picks, points, maxGWs, currentGW };
      
    } catch(err){
      console.error("Error in fetchSheetData:", err);
      throw err;
    }
  }

  function App(){
    const [state, setState] = useState(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    const [route, setRoute] = useHashRoute();
    const [lastUpdate, setLastUpdate] = useState(null);

    useEffect(() => {
      loadData();
    }, []);

    async function loadData(){
      setLoading(true);
      setError(null);
      try {
        const data = await fetchSheetData();
        setState(data);
        setLastUpdate(new Date().toLocaleTimeString());
      } catch(err){
        setError(err.message);
      } finally {
        setLoading(false);
      }
    }

    if(loading){
      return (
        <div className="wrap">
          <h1>EPL Picks Manager</h1>
          <div className="card loading">
            <div className="spinner"></div>
            <p style={{marginTop: 20}}>Loading data from Google Sheets...</p>
          </div>
        </div>
      );
    }

    if(error){
      return (
        <div className="wrap">
          <h1>EPL Picks Manager</h1>
          <div className="card">
            <h2>Error Loading Data</h2>
            <p className="bad">{error}</p>
            <p style={{marginTop: 12}}>
              <button className="primary" onClick={loadData}>Retry</button>
            </p>
          </div>
        </div>
      );
    }

    const { competitors, teams, picks, points, maxGWs, currentGW } = state;

    // Calculate all analytics
    const usageByCompetitorAndTeam = {};
    for (const c of competitors) {
      usageByCompetitorAndTeam[c] = {};
      for (const t of teams) usageByCompetitorAndTeam[c][t] = 0;
    }

    for (const c of competitors) {
      const row = picks?.[c] || {};
      for (let gw=1; gw<=maxGWs; gw++){
        const t = normaliseTeamName(row[gw]);
        if(t && usageByCompetitorAndTeam[c]?.[t] !== undefined) {
          usageByCompetitorAndTeam[c][t] += 1;
        }
      }
    }

    const totalTeamUsage = {};
    for (const t of teams) {
      totalTeamUsage[t] = 0;
      for (const c of competitors){
        totalTeamUsage[t] += (usageByCompetitorAndTeam[c]?.[t] || 0);
      }
    }

    const totalsByCompetitor = {};
    const weeklyPointsByCompetitor = {};
    for (const c of competitors){
      let sum = 0;
      weeklyPointsByCompetitor[c] = {};
      const row = points?.[c] || {};
      for(let gw=1; gw<=maxGWs; gw++){
        const pts = toInt(row[gw]);
        weeklyPointsByCompetitor[c][gw] = pts;
        sum += pts;
      }
      totalsByCompetitor[c] = sum;
    }

    const leaderboard = assignRanks(
      [...competitors]
        .map(c => ({ competitor: c, points: totalsByCompetitor[c] || 0 }))
        .sort((a,b) => b.points - a.points || a.competitor.localeCompare(b.competitor))
    ).map(item => ({ ...item, totalPoints: item.points }));

    // Team performance analytics
    const teamPerformance = {};
    for(const t of teams){
      const scores = [];
      for(const c of competitors){
        for(let gw=1; gw<=currentGW; gw++){
          if(picks?.[c]?.[gw] === t){
            scores.push(toInt(points?.[c]?.[gw]));
          }
        }
      }
      const total = scores.reduce((a,b) => a+b, 0);
      const avg = scores.length > 0 ? total / scores.length : 0;
      teamPerformance[t] = { total, avg, picks: scores.length };
    }

    function heatClass(val){
      if(val <= 0) return "heat0";
      if(val === 1) return "heat1";
      return "heat2";
    }

    function exportToCSV(data, filename){
      const csv = Papa.unparse(data);
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
    }

    function TopBar(){
      return (
        <>
          <h1>‚öΩ EPL Picks Manager</h1>
          
          <div className="readonly-banner">
            üîí Read-Only Mode ‚Ä¢ Last updated: {lastUpdate} ‚Ä¢ Current GW: {currentGW || 'TBD'} ‚Ä¢ 
            <a href="#" onClick={(e)=>{e.preventDefault(); loadData();}} style={{textDecoration:"underline", marginLeft: 8}}>Refresh</a>
          </div>

          <div className="tabs">
            <Tab label="üìä Dashboard" route="/dashboard" current={route} setRoute={setRoute} />
            <Tab label="üìã Picks" route="/picks" current={route} setRoute={setRoute} />
            <Tab label="üíØ Points" route="/points" current={route} setRoute={setRoute} />
            <Tab label="üìà Weekly" route="/weekly" current={route} setRoute={setRoute} />
            <Tab label="üèÜ Leaderboard" route="/leaderboard" current={route} setRoute={setRoute} />
            <Tab label="üìâ History" route="/history" current={route} setRoute={setRoute} />
            <Tab label="üî• Heatmap" route="/usage" current={route} setRoute={setRoute} />
            <Tab label="‚öîÔ∏è Head-to-Head" route="/h2h" current={route} setRoute={setRoute} />
            <Tab label="üéØ Teams" route="/teams" current={route} setRoute={setRoute} />
            <Tab label="üîÆ Predictions" route="/predictions" current={route} setRoute={setRoute} />
          </div>
        </>
      );
    }

    function DashboardPage(){
      const leader = leaderboard[0];
      const second = leaderboard[1];
      const gap = leader && second ? leader.totalPoints - second.totalPoints : 0;

      // Calculate stats
      let avgPerWeek = 0;
      let bestWeek = { gw: 0, competitor: '', points: 0 };
      let worstWeek = { gw: currentGW, competitor: '', points: Infinity };
      
      for(let gw=1; gw<=currentGW; gw++){
        for(const c of competitors){
          const pts = toInt(points?.[c]?.[gw]);
          avgPerWeek += pts;
          if(pts > bestWeek.points){
            bestWeek = { gw, competitor: c, points: pts };
          }
          if(pts < worstWeek.points && pts > 0){
            worstWeek = { gw, competitor: c, points: pts };
          }
        }
      }
      avgPerWeek = currentGW > 0 ? (avgPerWeek / (currentGW * competitors.length)).toFixed(1) : 0;

      // Most consistent (lowest variance)
      const variances = competitors.map(c => {
        const weeklyPts = [];
        for(let gw=1; gw<=currentGW; gw++){
          weeklyPts.push(toInt(points?.[c]?.[gw]));
        }
        const avg = weeklyPts.reduce((a,b)=>a+b,0) / weeklyPts.length;
        const variance = weeklyPts.reduce((sum, val) => sum + Math.pow(val - avg, 2), 0) / weeklyPts.length;
        return { competitor: c, variance, stdDev: Math.sqrt(variance) };
      });
      const mostConsistent = variances.sort((a,b) => a.variance - b.variance)[0];

      // Biggest comeback
      let biggestClimb = { competitor: '', change: 0 };
      if(currentGW >= 2){
        const history = [];
        for(let gw=1; gw<=currentGW; gw++){
          const standings = competitors.map(c => {
            let cumPts = 0;
            for(let w=1; w<=gw; w++) cumPts += toInt(points?.[c]?.[w]);
            return { competitor: c, points: cumPts };
          });
          standings.sort((a,b) => b.points - a.points);
          history.push(standings.map((s,i) => ({ ...s, rank: i+1 })));
        }
        
        for(const c of competitors){
          const firstRank = history[0]?.find(s => s.competitor === c)?.rank || 0;
          const lastRank = history[currentGW-1]?.find(s => s.competitor === c)?.rank || 0;
          const change = firstRank - lastRank;
          if(change > biggestClimb.change){
            biggestClimb = { competitor: c, change };
          }
        }
      }

      // Ties ‚Äî group every set of 2+ competitors that share the same points
      const tieGroups = [];
      let i = 0;
      while(i < leaderboard.length){
        let j = i;
        while(j < leaderboard.length && leaderboard[j].totalPoints === leaderboard[i].totalPoints) j++;
        if(j - i > 1){
          const names = leaderboard.slice(i, j).map(r => r.competitor);
          const rankLabel = leaderboard[i].rank === 1 ? '1st' : leaderboard[i].rank === 2 ? '2nd' : leaderboard[i].rank === 3 ? '3rd' : `${leaderboard[i].rank}th`;
          tieGroups.push({ rankLabel, names, points: leaderboard[i].totalPoints });
        }
        i = j;
      }

      return (
        <>
          <div className="card">
            <h2>üèÜ Current Standings</h2>
            <div className="highlight-box">
              <div style={{fontSize: 18, marginBottom: 8}}>
                {leaderboard.length > 1 && leaderboard[0].totalPoints === leaderboard[1].totalPoints ? (
                  <>
                    <strong>Joint 1st Place:</strong>{' '}
                    <span className="ok">
                      {leaderboard.filter(r => r.totalPoints === leaderboard[0].totalPoints).map(r => r.competitor).join(', ')}
                    </span>
                    {' '}with <span className="ok">{leaderboard[0].totalPoints} points</span>
                  </>
                ) : (
                  <>
                    <strong>1st Place: {leader?.competitor}</strong> with <span className="ok">{leader?.totalPoints} points</span>
                  </>
                )}
              </div>
              {gap > 0 && (
                <div className="muted">
                  Leading by {gap} point{gap !== 1 ? 's' : ''} over {second?.competitor}
                </div>
              )}
              {tieGroups.length > 0 && (
                <div className="warn" style={{marginTop: 8}}>
                  {tieGroups.map((g, idx) => (
                    <div key={idx}>‚ö†Ô∏è Joint {g.rankLabel}: {g.names.join(', ')} ({g.points} pts)</div>
                  ))}
                </div>
              )}
            </div>
          </div>

          <div className="stat-grid">
            <div className="stat-card">
              <div className="stat-label">Avg Points/Week</div>
              <div className="stat-value">{avgPerWeek}</div>
            </div>
            <div className="stat-card">
              <div className="stat-label">Best Single Week</div>
              <div className="stat-value ok">{bestWeek.points}</div>
              <div className="muted">{bestWeek.competitor} (GW{bestWeek.gw})</div>
            </div>
            <div className="stat-card">
              <div className="stat-label">Most Consistent</div>
              <div className="stat-value">{mostConsistent?.competitor}</div>
              <div className="muted">œÉ = {mostConsistent?.stdDev.toFixed(1)}</div>
            </div>
            <div className="stat-card">
              <div className="stat-label">Biggest Climber</div>
              <div className="stat-value ok">‚Üë{biggestClimb.change}</div>
              <div className="muted">{biggestClimb.competitor}</div>
            </div>
          </div>

          <div className="card">
            <h2>üìä Quick Stats</h2>
            <div className="grid">
              <table>
                <thead>
                  <tr>
                    <th>Rank</th>
                    <th>Competitor</th>
                    <th className="right">Total</th>
                    <th className="right">Avg/Week</th>
                    <th className="right">Last Week</th>
                  </tr>
                </thead>
                <tbody>
                  {leaderboard.map((r) => {
                    const avgWeek = currentGW > 0 ? (r.totalPoints / currentGW).toFixed(1) : 0;
                    const lastWeek = currentGW > 0 ? toInt(points?.[r.competitor]?.[currentGW]) : 0;
                    return (
                      <tr key={r.competitor}>
                        <td>{r.rank}</td>
                        <td><b>{r.competitor}</b></td>
                        <td className="right"><b>{r.totalPoints}</b></td>
                        <td className="right">{avgWeek}</td>
                        <td className="right">{lastWeek || '‚Äî'}</td>
                      </tr>
                    );
                  })}
                </tbody>
              </table>
            </div>
          </div>
        </>
      );
    }

    function PicksPage(){
      return (
        <div className="card">
          <h2>Picks (by Gameweek)</h2>

          <div className="grid">
            <table>
              <thead>
                <tr>
                  <th className="sticky">Competitor</th>
                  {Array.from({length:maxGWs}, (_,i)=>i+1).map(gw => (
                    <th key={gw}>GW{gw}</th>
                  ))}
                </tr>
              </thead>
              <tbody>
                {competitors.map(c => (
                  <tr key={c}>
                    <td className="sticky">{c}</td>
                    {Array.from({length:maxGWs}, (_,i)=>i+1).map(gw => {
                      const team = picks?.[c]?.[gw] || "‚Äî";
                      return <td key={gw}>{team}</td>;
                    })}
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        </div>
      );
    }

    function PointsPage(){
      return (
        <div className="card">
          <h2>Cumulative Points (by Gameweek)</h2>

          <div className="grid">
            <table>
              <thead>
                <tr>
                  <th className="sticky">Competitor</th>
                  {Array.from({length:maxGWs}, (_,i)=>i+1).map(gw => (
                    <th key={gw}>GW{gw}</th>
                  ))}
                  <th>Total</th>
                </tr>
              </thead>
              <tbody>
                {competitors.map(c => (
                  <tr key={c}>
                    <td className="sticky">{c}</td>
                    {Array.from({length:maxGWs}, (_,i)=>i+1).map(gw => {
                      const pts = points?.[c]?.[gw] || "";
                      return <td key={gw} className="right">{pts}</td>;
                    })}
                    <td className="right"><b>{totalsByCompetitor[c] || 0}</b></td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>

          <button className="primary export-btn" onClick={() => {
            const data = competitors.map(c => {
              const row = { Competitor: c };
              for(let gw=1; gw<=maxGWs; gw++){
                row[`GW${gw}`] = points?.[c]?.[gw] || '';
              }
              row.Total = totalsByCompetitor[c] || 0;
              return row;
            });
            exportToCSV(data, 'points.csv');
          }}>
            üì• Export to CSV
          </button>
        </div>
      );
    }

    function WeeklyPointsPage(){
      const [selectedGW, setSelectedGW] = useState(currentGW || 1);

      // For each team picked this GW, figure out if the team has played.
      // A team is considered "played" if at least one competitor who picked
      // that team in this GW has a points value recorded (including 0 explicitly set).
      // We treat it as "not played" only when NO competitor who picked that team has
      // any points value AND the current GW points aren't in yet for anyone picking it.
      function hasTeamPlayed(team, gw){
        // If this GW is beyond currentGW, definitely not played
        if(gw > currentGW) return false;
        // Check: does any competitor who picked this team in this GW have points data?
        for(const c of competitors){
          if(picks?.[c]?.[gw] === team){
            // points sheet has an entry for this competitor this GW
            if(points?.[c]?.[gw] !== undefined && points?.[c]?.[gw] !== null) return true;
          }
        }
        // Fallback: if the GW < currentGW it has definitely been played
        if(gw < currentGW) return true;
        return false;
      }

      const weekData = competitors.map(c => {
        const team = picks?.[c]?.[selectedGW] || null;
        const pts = toInt(points?.[c]?.[selectedGW]);
        const played = team ? hasTeamPlayed(team, selectedGW) : false;
        return { competitor: c, team, points: pts, played };
      }).sort((a,b) => b.points - a.points);

      // Only count competitors whose team has played for best/worst
      const playedData = weekData.filter(d => d.played);
      const bestThisWeek = playedData[0] || null;
      const worstThisWeek = playedData[playedData.length - 1] || null;

      return (
        <div className="card">
          <h2>Weekly Points Performance</h2>

          <div className="selector">
            <label>Select Gameweek: </label>
            <select value={selectedGW} onChange={(e) => setSelectedGW(parseInt(e.target.value))}>
              {Array.from({length: currentGW || maxGWs}, (_,i)=>i+1).map(gw => (
                <option key={gw} value={gw}>GW {gw}</option>
              ))}
            </select>
          </div>

          <div className="highlight-box">
            <div>
              <span className="ok">üèÜ Best: {bestThisWeek?.competitor}</span> ({bestThisWeek?.points} pts ‚Äî {bestThisWeek?.team})
            </div>
            <div style={{marginTop: 4}}>
              <span className="bad">üìâ Worst: {worstThisWeek?.competitor}</span> ({worstThisWeek?.points} pts ‚Äî {worstThisWeek?.team})
            </div>
            {playedData.length < weekData.length && (
              <div className="warn" style={{marginTop: 4}}>
                ‚è≥ {weekData.length - playedData.length} team{weekData.length - playedData.length !== 1 ? 's' : ''} yet to play
              </div>
            )}
          </div>

          <div className="grid">
            <table>
              <thead>
                <tr>
                  <th>Rank</th>
                  <th>Competitor</th>
                  <th>Team Picked</th>
                  <th>Status</th>
                  <th className="right">Points</th>
                </tr>
              </thead>
              <tbody>
                {weekData.map((r, idx) => (
                  <tr key={r.competitor}>
                    <td>{idx + 1}</td>
                    <td><b>{r.competitor}</b></td>
                    <td>{r.team || '‚Äî'}</td>
                    <td>
                      {r.played
                        ? <span className="ok">‚úÖ Played</span>
                        : <span className="warn">‚è≥ Pending</span>
                      }
                    </td>
                    <td className="right">{r.played ? r.points : '‚Äî'}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>

          <button className="primary export-btn" onClick={() => {
            const data = weekData.map((r, idx) => ({
              Rank: idx + 1,
              Competitor: r.competitor,
              Team: picks?.[r.competitor]?.[selectedGW] || '‚Äî',
              Points: r.points
            }));
            exportToCSV(data, `gw${selectedGW}_results.csv`);
          }}>
            üì• Export GW{selectedGW} to CSV
          </button>
        </div>
      );
    }

    function LeaderboardPage(){
      return (
        <div className="card">
          <h2>Leaderboard</h2>
          <div className="grid">
            <table>
              <thead>
                <tr>
                  <th>Rank</th>
                  <th>Competitor</th>
                  <th className="right">Total Points</th>
                </tr>
              </thead>
              <tbody>
                {leaderboard.map((r) => (
                  <tr key={r.competitor}>
                    <td>{r.rank}</td>
                    <td><b>{r.competitor}</b></td>
                    <td className="right"><b>{r.totalPoints}</b></td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>

          <button className="primary export-btn" onClick={() => {
            const data = leaderboard.map((r) => ({
              Rank: r.rank,
              Competitor: r.competitor,
              TotalPoints: r.totalPoints
            }));
            exportToCSV(data, 'leaderboard.csv');
          }}>
            üì• Export Leaderboard
          </button>
        </div>
      );
    }

    function LeaderboardHistoryPage(){
      const [viewMode, setViewMode] = useState('graph');
      const chartRef = useRef(null);
      const chartInstanceRef = useRef(null);

      const effectiveGW = currentGW || maxGWs;
      const history = [];
      
      for(let gw=1; gw<=effectiveGW; gw++){
        const standings = competitors.map(c => {
          let cumulativePoints = 0;
          for(let week=1; week<=gw; week++){
            cumulativePoints += toInt(points?.[c]?.[week]);
          }
          return { competitor: c, points: cumulativePoints };
        });
        
        standings.sort((a,b) => b.points - a.points || a.competitor.localeCompare(b.competitor));
        
        const rankedStandings = assignRanks(standings);
        
        history.push({ gw, standings: rankedStandings });
      }

      const gwsWithData = history.filter(h => 
        h.standings.some(s => s.points > 0)
      );

      const colors = [
        '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF',
        '#FF9F40', '#FF6384', '#C9CBCF', '#4BC0C0', '#FF6384'
      ];

      useEffect(() => {
        if(viewMode === 'graph' && chartRef.current && gwsWithData.length > 0){
          if(chartInstanceRef.current){
            chartInstanceRef.current.destroy();
          }

          const ctx = chartRef.current.getContext('2d');
          
          const labels = gwsWithData.map(h => `GW${h.gw}`);
          const datasets = competitors.map((c, idx) => {
            const data = gwsWithData.map(h => {
              const standing = h.standings.find(s => s.competitor === c);
              return standing ? standing.rank : null;
            });
            
            return {
              label: c,
              data: data,
              borderColor: colors[idx % colors.length],
              backgroundColor: colors[idx % colors.length] + '20',
              tension: 0.1,
              pointRadius: 3,
              pointHoverRadius: 5
            };
          });

          chartInstanceRef.current = new Chart(ctx, {
            type: 'line',
            data: {
              labels: labels,
              datasets: datasets
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: {
                  position: 'bottom',
                  labels: {
                    color: '#e7eefc',
                    padding: 10,
                    font: { size: 11 }
                  }
                },
                tooltip: {
                  mode: 'index',
                  intersect: false
                }
              },
              scales: {
                y: {
                  reverse: true,
                  beginAtZero: false,
                  ticks: {
                    stepSize: 1,
                    color: '#9fb0d0'
                  },
                  grid: { color: '#233458' },
                  title: {
                    display: true,
                    text: 'Position',
                    color: '#9fb0d0'
                  }
                },
                x: {
                  ticks: { color: '#9fb0d0' },
                  grid: { color: '#233458' },
                  title: {
                    display: true,
                    text: 'Gameweek',
                    color: '#9fb0d0'
                  }
                }
              }
            }
          });
        }

        return () => {
          if(chartInstanceRef.current){
            chartInstanceRef.current.destroy();
          }
        };
      }, [viewMode, gwsWithData]);

      return (
        <div className="card">
          <h2>Leaderboard Position History (GW 1 - {effectiveGW})</h2>
          
          <div className="view-toggle">
            <button 
              className={viewMode === 'graph' ? 'primary small' : 'small'}
              onClick={() => setViewMode('graph')}
            >
              üìà Graph View
            </button>
            <button 
              className={viewMode === 'table' ? 'primary small' : 'small'}
              onClick={() => setViewMode('table')}
            >
              üìä Table View
            </button>
          </div>

          {viewMode === 'graph' ? (
            <>
              <div className="muted" style={{marginBottom:10}}>
                Line graph showing position changes over time. Lower is better (1st place at top).
              </div>
              <div className="chart-container">
                <canvas ref={chartRef}></canvas>
              </div>
            </>
          ) : (
            <>
              <div className="grid">
                <table>
                  <thead>
                    <tr>
                      <th className="sticky">Competitor</th>
                      {gwsWithData.map(h => (
                        <th key={h.gw} className="center">GW{h.gw}</th>
                      ))}
                    </tr>
                  </thead>
                  <tbody>
                    {competitors.map(c => {
                      return (
                        <tr key={c}>
                          <td className="sticky">{c}</td>
                          {gwsWithData.map((h, gwIdx) => {
                            const standing = h.standings.find(s => s.competitor === c);
                            const rank = standing ? standing.rank : "‚Äî";
                            const points = standing ? standing.points : 0;
                            
                            let prevRank = null;
                            if(gwIdx > 0){
                              const prevStanding = gwsWithData[gwIdx - 1].standings.find(s => s.competitor === c);
                              prevRank = prevStanding ? prevStanding.rank : null;
                            }
                            
                            let changeIndicator = "";
                            let changeClass = "";
                            if(prevRank !== null && rank !== "‚Äî"){
                              const change = prevRank - rank;
                              if(change > 0){
                                changeIndicator = ` ‚Üë${change}`;
                                changeClass = "rank-up";
                              } else if(change < 0){
                                changeIndicator = ` ‚Üì${Math.abs(change)}`;
                                changeClass = "rank-down";
                              } else {
                                changeIndicator = " ‚îÄ";
                                changeClass = "rank-same";
                              }
                            }
                            
                            let className = "center";
                            if(rank === 1) className += " rank-1";
                            else if(rank === 2) className += " rank-2";
                            else if(rank === 3) className += " rank-3";
                            
                            return (
                              <td key={h.gw} className={className} title={`${points} pts`}>
                                <div>
                                  <span style={{fontWeight: rank <= 3 ? 800 : 600}}>{rank}</span>
                                  {changeIndicator && (
                                    <span className={changeClass} style={{fontSize: 10, marginLeft: 2}}>
                                      {changeIndicator}
                                    </span>
                                  )}
                                </div>
                              </td>
                            );
                          })}
                        </tr>
                      );
                    })}
                  </tbody>
                </table>
              </div>
            </>
          )}

          <button className="primary export-btn" onClick={() => {
            const data = [];
            for(const h of gwsWithData){
              for(const s of h.standings){
                data.push({
                  Gameweek: h.gw,
                  Competitor: s.competitor,
                  Rank: s.rank,
                  CumulativePoints: s.points
                });
              }
            }
            exportToCSV(data, 'leaderboard_history.csv');
          }}>
            üì• Export History
          </button>
        </div>
      );
    }

    function UsagePage(){
      return (
        <div className="card">
          <h2>Usage Heatmap (0/1/2)</h2>
          <div className="muted" style={{marginBottom:10}}>
            Green = 0 used, Amber = 1 used, Red = 2 used (maxed out).
          </div>
          <div className="grid">
            <table>
              <thead>
                <tr>
                  <th className="sticky">Team</th>
                  {competitors.map(c => <th key={c}>{c}</th>)}
                  <th>Total</th>
                </tr>
              </thead>
              <tbody>
                {teams.map(team => {
                  const total = (totalTeamUsage[team] ?? 0);
                  return (
                    <tr key={team}>
                      <td className="sticky">{team}</td>
                      {competitors.map(c => {
                        const v = usageByCompetitorAndTeam?.[c]?.[team] || 0;
                        return (
                          <td key={c} className={heatClass(v)} style={{textAlign:"center", fontWeight:800}}>
                            {v}
                          </td>
                        );
                      })}
                      <td style={{textAlign:"center"}}>{total}</td>
                    </tr>
                  );
                })}
              </tbody>
            </table>
          </div>
        </div>
      );
    }

    function HeadToHeadPage(){
      const [comp1, setComp1] = useState(competitors[0] || '');
      const [comp2, setComp2] = useState(competitors[1] || '');

      const samePicksCount = Array.from({length: currentGW}, (_,i)=>i+1).filter(gw => 
        picks?.[comp1]?.[gw] === picks?.[comp2]?.[gw] && picks?.[comp1]?.[gw]
      ).length;

      const comp1Total = totalsByCompetitor[comp1] || 0;
      const comp2Total = totalsByCompetitor[comp2] || 0;

      return (
        <>
          <div className="card">
            <h2>‚öîÔ∏è Head-to-Head Comparison</h2>
            
            <div className="comparison-grid">
              <div className="selector">
                <label>Competitor 1:</label>
                <select value={comp1} onChange={(e) => setComp1(e.target.value)}>
                  {competitors.map(c => <option key={c} value={c}>{c}</option>)}
                </select>
              </div>
              <div className="selector">
                <label>Competitor 2:</label>
                <select value={comp2} onChange={(e) => setComp2(e.target.value)}>
                  {competitors.map(c => <option key={c} value={c}>{c}</option>)}
                </select>
              </div>
            </div>

            <div className="highlight-box">
              <div className="stat-grid">
                <div>
                  <div className="stat-label">{comp1} Total</div>
                  <div className="stat-value">{comp1Total}</div>
                </div>
                <div>
                  <div className="stat-label">{comp2} Total</div>
                  <div className="stat-value">{comp2Total}</div>
                </div>
                <div>
                  <div className="stat-label">Gap</div>
                  <div className="stat-value">{Math.abs(comp1Total - comp2Total)}</div>
                </div>
                <div>
                  <div className="stat-label">Same Picks</div>
                  <div className="stat-value">{samePicksCount}</div>
                </div>
              </div>
            </div>
          </div>

          <div className="card">
            <h2>Pick Comparison</h2>
            <div className="grid">
              <table>
                <thead>
                  <tr>
                    <th>GW</th>
                    <th>{comp1}</th>
                    <th>{comp2}</th>
                    <th className="right">{comp1} Pts</th>
                    <th className="right">{comp2} Pts</th>
                    <th>Winner</th>
                  </tr>
                </thead>
                <tbody>
                  {Array.from({length: currentGW || 1}, (_,i)=>i+1).map(gw => {
                    const pick1 = picks?.[comp1]?.[gw] || '‚Äî';
                    const pick2 = picks?.[comp2]?.[gw] || '‚Äî';
                    const pts1 = toInt(points?.[comp1]?.[gw]);
                    const pts2 = toInt(points?.[comp2]?.[gw]);
                    const winner = pts1 > pts2 ? comp1 : pts2 > pts1 ? comp2 : 'Tie';
                    const samePick = pick1 === pick2 && pick1 !== '‚Äî';
                    
                    return (
                      <tr key={gw} style={samePick ? {background: 'rgba(27,59,255,0.1)'} : {}}>
                        <td>{gw}</td>
                        <td>{pick1}</td>
                        <td>{pick2}</td>
                        <td className="right">{pts1 || '‚Äî'}</td>
                        <td className="right">{pts2 || '‚Äî'}</td>
                        <td>{winner}</td>
                      </tr>
                    );
                  })}
                </tbody>
              </table>
            </div>
          </div>
        </>
      );
    }

    function TeamsPage(){
      const sortedTeams = [...teams].sort((a,b) => {
        return (teamPerformance[b]?.avg || 0) - (teamPerformance[a]?.avg || 0);
      });

      const bestTeam = sortedTeams[0];
      const worstTeam = sortedTeams[sortedTeams.length - 1];

      return (
        <div className="card">
          <h2>üéØ Team Performance Analytics</h2>

          <div className="highlight-box">
            <div className="stat-grid">
              <div>
                <div className="stat-label">Best Average</div>
                <div className="stat-value ok">{bestTeam}</div>
                <div className="muted">{teamPerformance[bestTeam]?.avg.toFixed(1)} pts/pick</div>
              </div>
              <div>
                <div className="stat-label">Most Picked</div>
                <div className="stat-value">
                  {[...teams].sort((a,b) => teamPerformance[b]?.picks - teamPerformance[a]?.picks)[0]}
                </div>
                <div className="muted">
                  {teamPerformance[[...teams].sort((a,b) => teamPerformance[b]?.picks - teamPerformance[a]?.picks)[0]]?.picks} times
                </div>
              </div>
              <div>
                <div className="stat-label">Least Picked</div>
                <div className="stat-value">
                  {[...teams].sort((a,b) => teamPerformance[a]?.picks - teamPerformance[b]?.picks)[0]}
                </div>
                <div className="muted">
                  {teamPerformance[[...teams].sort((a,b) => teamPerformance[a]?.picks - teamPerformance[b]?.picks)[0]]?.picks} times
                </div>
              </div>
            </div>
          </div>

          <div className="grid">
            <table>
              <thead>
                <tr>
                  <th>Team</th>
                  <th className="right">Times Picked</th>
                  <th className="right">Total Points</th>
                  <th className="right">Avg Points/Pick</th>
                  <th>Value Rating</th>
                </tr>
              </thead>
              <tbody>
                {sortedTeams.map(team => {
                  const perf = teamPerformance[team] || { total: 0, avg: 0, picks: 0 };
                  const usage = totalTeamUsage[team] || 0;
                  const valueScore = perf.picks > 0 ? perf.avg / (usage / competitors.length) : 0;
                  
                  return (
                    <tr key={team}>
                      <td><b>{team}</b></td>
                      <td className="right">{perf.picks}</td>
                      <td className="right">{perf.total}</td>
                      <td className="right">{perf.avg.toFixed(1)}</td>
                      <td>
                        {valueScore > 1.5 ? 'üî• Hot' : valueScore > 1 ? '‚úÖ Good' : valueScore > 0.5 ? '‚ö†Ô∏è OK' : '‚ùÑÔ∏è Cold'}
                      </td>
                    </tr>
                  );
                })}
              </tbody>
            </table>
          </div>
        </div>
      );
    }

    function PredictionsPage(){
      const remainingGWs = maxGWs - (currentGW || 0);

      // Derive the actual highest single-week score seen in the data
      let highestWeeklyScore = 0;
      for(const c of competitors){
        for(let gw=1; gw<=currentGW; gw++){
          const pts = toInt(points?.[c]?.[gw]);
          if(pts > highestWeeklyScore) highestWeeklyScore = pts;
        }
      }
      // If no data at all, fall back to a reasonable default
      if(highestWeeklyScore === 0) highestWeeklyScore = 10;
      
      const projections = competitors.map(c => {
        const currentTotal = totalsByCompetitor[c] || 0;
        const avgPerWeek = currentGW > 0 ? currentTotal / currentGW : 0;
        const projected = currentTotal + (avgPerWeek * remainingGWs);
        const maxPossible = currentTotal + (highestWeeklyScore * remainingGWs);
        
        return {
          competitor: c,
          current: currentTotal,
          avgPerWeek: avgPerWeek.toFixed(1),
          projected: Math.round(projected),
          maxPossible: Math.round(maxPossible)
        };
      }).sort((a,b) => b.projected - a.projected);

      const leader = projections[0];
      const second = projections[1];
      const pointsNeeded = second ? Math.max(0, (leader.projected - second.current) + 1) : 0;

      // Remaining picks analysis
      const remainingPicks = {};
      for(const c of competitors){
        remainingPicks[c] = {};
        for(const t of teams){
          const used = usageByCompetitorAndTeam[c][t] || 0;
          remainingPicks[c][t] = Math.max(0, 2 - used);
        }
      }

      return (
        <>
          <div className="card">
            <h2>üîÆ Season Projections</h2>
            
            <div className="highlight-box">
              <div className="stat-grid">
                <div>
                  <div className="stat-label">Gameweeks Remaining</div>
                  <div className="stat-value">{remainingGWs}</div>
                </div>
                <div>
                  <div className="stat-label">Projected Winner</div>
                  <div className="stat-value ok">{leader?.competitor}</div>
                  <div className="muted">{leader?.projected} pts (projected)</div>
                </div>
                <div>
                  <div className="stat-label">Points to Catch Leader</div>
                  <div className="stat-value warn">{pointsNeeded}</div>
                  <div className="muted">For {second?.competitor}</div>
                </div>
              </div>
            </div>

            <div className="grid">
              <table>
                <thead>
                  <tr>
                    <th>Competitor</th>
                    <th className="right">Current</th>
                    <th className="right">Avg/Week</th>
                    <th className="right">Projected Final</th>
                    <th className="right">Max Possible</th>
                  </tr>
                </thead>
                <tbody>
                  {projections.map(p => (
                    <tr key={p.competitor}>
                      <td><b>{p.competitor}</b></td>
                      <td className="right">{p.current}</td>
                      <td className="right">{p.avgPerWeek}</td>
                      <td className="right"><b>{p.projected}</b></td>
                      <td className="right">{p.maxPossible}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>

          <div className="muted" style={{marginTop: 8}}>
            üìå "Max Possible" assumes every remaining week scores the season-best weekly score ({highestWeeklyScore} pts).  
            "Projected Final" assumes each competitor continues at their current average.
          </div>
            <div className="muted" style={{marginBottom:10}}>
              Shows how many times each competitor can still pick each team (max 2 per team).
            </div>
            <div className="grid">
              <table>
                <thead>
                  <tr>
                    <th className="sticky">Team</th>
                    {competitors.map(c => <th key={c}>{c}</th>)}
                  </tr>
                </thead>
                <tbody>
                  {teams.map(team => (
                    <tr key={team}>
                      <td className="sticky">{team}</td>
                      {competitors.map(c => {
                        const remaining = remainingPicks[c][team] || 0;
                        const className = remaining === 0 ? 'heat2' : remaining === 1 ? 'heat1' : 'heat0';
                        return (
                          <td key={c} className={className} style={{textAlign:"center", fontWeight:800}}>
                            {remaining}
                          </td>
                        );
                      })}
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>
        </>
      );
    }

    function NotFound(){
      return (
        <div className="card">
          <h2>Page not found</h2>
          <div className="muted">Use the tabs above.</div>
        </div>
      );
    }

    let page = null;
    if(route === "/dashboard") page = <DashboardPage />;
    else if(route === "/picks") page = <PicksPage />;
    else if(route === "/points") page = <PointsPage />;
    else if(route === "/weekly") page = <WeeklyPointsPage />;
    else if(route === "/leaderboard") page = <LeaderboardPage />;
    else if(route === "/history") page = <LeaderboardHistoryPage />;
    else if(route === "/usage") page = <UsagePage />;
    else if(route === "/h2h") page = <HeadToHeadPage />;
    else if(route === "/teams") page = <TeamsPage />;
    else if(route === "/predictions") page = <PredictionsPage />;
    else page = <NotFound />;

    return (
      <div className="wrap">
        <TopBar />
        {page}
      </div>
    );
  }

  ReactDOM.createRoot(document.getElementById("root")).render(<App />);
</script>
``

  </body>
</html>